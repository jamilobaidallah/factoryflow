rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS - Authentication
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is the data owner (legacy check - user owns this data)
    function isDataOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Check if user is a team member of this data owner
    // Used for multi-tenant access: viewers/accountants accessing their owner's data
    function isTeamMemberOf(dataOwnerId) {
      let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return userDoc != null && userDoc.data.ownerId == dataOwnerId;
    }

    // Check if user can access this owner's data (owner OR team member)
    function canAccessOwnerData(userId) {
      return isAuthenticated() && (
        request.auth.uid == userId ||  // User is the owner
        isTeamMemberOf(userId)          // User is a team member of this owner
      );
    }

    // ============================================
    // HELPER FUNCTIONS - RBAC (Role-Based Access)
    // ============================================

    // Get user's role from their profile document
    // Returns 'owner' as default for backwards compatibility
    // Handles: missing document, missing role field, null role value
    function getUserRole(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return (userDoc != null && userDoc.data.role != null) ? userDoc.data.role : 'owner';
    }

    // Check if user has 'owner' role
    function isRoleOwner(userId) {
      return getUserRole(userId) == 'owner';
    }

    // Check if user can write (owner or accountant)
    function canWrite(userId) {
      let role = getUserRole(userId);
      return role == 'owner' || role == 'accountant';
    }

    // Check if user can read (any valid role)
    function canRead(userId) {
      let role = getUserRole(userId);
      return role == 'owner' || role == 'accountant' || role == 'viewer';
    }

    // ============================================
    // HELPER FUNCTIONS - Validation
    // ============================================

    function isValidNumber(value) {
      return value is number && value >= 0;
    }

    function isValidAmount(value) {
      return value is number && value > 0;
    }

    function isValidPercentage(value) {
      return value is number && value >= 0 && value <= 100;
    }

    function isValidString(value) {
      return value is string && value.size() > 0 && value.size() <= 500;
    }

    function hasRequiredFields(fields) {
      return request.resource.data.keys().hasAll(fields);
    }

    // ============================================
    // USER PROFILE DOCUMENT
    // ============================================

    match /users/{userId} {
      // Read permissions:
      // 1. Read own profile: any authenticated user can read their own profile
      // 2. Find owners: any authenticated user can read profiles where role == 'owner'
      //    This allows new users to find factory owners when submitting access requests
      allow read: if isAuthenticated() && (
        isDataOwner(userId) ||
        resource.data.role == 'owner'
      );

      // Write own profile: data owner can write their own profile
      allow write: if isDataOwner(userId);

      // Allow owner to update team member's role
      // Owner can update users where ownerId matches the owner's uid
      allow update: if isAuthenticated()
        && resource.data.ownerId == request.auth.uid
        && isRoleOwner(request.auth.uid);

      // Allow owner to CREATE a new team member's user document
      // This happens when approving an access request
      // The new document must have ownerId pointing to the creating owner
      allow create: if isAuthenticated()
        && isRoleOwner(request.auth.uid)
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.role in ['accountant', 'viewer'];

      // ============================================
      // SUBCOLLECTIONS - Team Members
      // ============================================

      // Members collection - team members under this owner
      // Owner can manage their team members
      match /members/{memberId} {
        allow read: if canAccessOwnerData(userId);
        allow write: if isDataOwner(userId) && isRoleOwner(request.auth.uid);
      }

      // ============================================
      // SUBCOLLECTIONS - Data Collections
      // ============================================

      // Ledger collection - accounting entries
      match /ledger/{ledgerId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['transactionId', 'description', 'type', 'amount', 'category', 'date', 'createdAt'])
          && isValidString(request.resource.data.description)
          && isValidAmount(request.resource.data.amount)
          && request.resource.data.type in ['دخل', 'إيراد', 'مصروف', 'حركة رأس مال']
          && isValidString(request.resource.data.category)
          && request.resource.data.date is timestamp
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && request.resource.data.transactionId == resource.data.transactionId
          && isValidString(request.resource.data.description)
          && isValidAmount(request.resource.data.amount);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Partners collection - business partners/owners
      match /partners/{partnerId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['name', 'ownershipPercentage', 'initialInvestment', 'joinDate', 'active'])
          && isValidString(request.resource.data.name)
          && isValidPercentage(request.resource.data.ownershipPercentage)
          && isValidNumber(request.resource.data.initialInvestment)
          && request.resource.data.joinDate is timestamp
          && request.resource.data.active is bool;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && isValidString(request.resource.data.name)
          && isValidPercentage(request.resource.data.ownershipPercentage)
          && isValidNumber(request.resource.data.initialInvestment);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Clients collection
      match /clients/{clientId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['name', 'createdAt'])
          && isValidString(request.resource.data.name)
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && isValidString(request.resource.data.name);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Payments collection
      match /payments/{paymentId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['clientName', 'amount', 'type', 'date', 'createdAt'])
          && isValidString(request.resource.data.clientName)
          && isValidAmount(request.resource.data.amount)
          && request.resource.data.type in ['قبض', 'صرف']
          && request.resource.data.date is timestamp
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && isValidAmount(request.resource.data.amount);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);

        // Payment allocations subcollection (for multi-allocation payments)
        match /allocations/{allocationId} {
          allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
          allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
            && hasRequiredFields(['transactionId', 'ledgerDocId', 'allocatedAmount', 'createdAt'])
            && isValidAmount(request.resource.data.allocatedAmount)
            && request.resource.data.createdAt is timestamp;
          allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
        }
      }

      // Cheques collection
      match /cheques/{chequeId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['chequeNumber', 'clientName', 'amount', 'type', 'status', 'dueDate', 'createdAt'])
          && isValidString(request.resource.data.chequeNumber)
          && isValidString(request.resource.data.clientName)
          && isValidAmount(request.resource.data.amount)
          && request.resource.data.type in ['وارد', 'صادر']
          && request.resource.data.status in ['قيد الانتظار', 'محصل', 'مرتجع', 'ملغي', 'مجيّر', 'مرفوض', 'تم الصرف']
          && request.resource.data.dueDate is timestamp
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && request.resource.data.status in ['قيد الانتظار', 'محصل', 'مرتجع', 'ملغي', 'مجيّر', 'مرفوض', 'تم الصرف'];
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Inventory collection
      match /inventory/{itemId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['itemName', 'quantity', 'unit', 'createdAt'])
          && isValidString(request.resource.data.itemName)
          && isValidNumber(request.resource.data.quantity)
          && isValidString(request.resource.data.unit)
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && isValidNumber(request.resource.data.quantity);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Fixed Assets collection
      match /fixedAssets/{assetId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['assetName', 'purchaseAmount', 'purchaseDate', 'usefulLifeYears', 'createdAt'])
          && isValidString(request.resource.data.assetName)
          && isValidAmount(request.resource.data.purchaseAmount)
          && request.resource.data.purchaseDate is timestamp
          && isValidNumber(request.resource.data.usefulLifeYears)
          && request.resource.data.usefulLifeYears > 0
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Production collection
      match /production/{productionId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['outputItemName', 'outputQuantity', 'productionDate', 'createdAt'])
          && isValidString(request.resource.data.outputItemName)
          && isValidNumber(request.resource.data.outputQuantity)
          && request.resource.data.outputQuantity > 0
          && request.resource.data.productionDate is timestamp
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Employees collection
      match /employees/{employeeId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['name', 'position', 'salary', 'hireDate', 'active', 'createdAt'])
          && isValidString(request.resource.data.name)
          && isValidString(request.resource.data.position)
          && isValidNumber(request.resource.data.salary)
          && request.resource.data.hireDate is timestamp
          && request.resource.data.active is bool
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && isValidNumber(request.resource.data.salary)
          && request.resource.data.active is bool;
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Invoices collection
      match /invoices/{invoiceId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['invoiceNumber', 'clientName', 'totalAmount', 'issueDate', 'createdAt'])
          && isValidString(request.resource.data.invoiceNumber)
          && isValidString(request.resource.data.clientName)
          && isValidAmount(request.resource.data.totalAmount)
          && request.resource.data.issueDate is timestamp
          && request.resource.data.createdAt is timestamp;
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Activity Logs collection - سجل النشاطات (immutable audit trail)
      match /activity_logs/{logId} {
        // Read: anyone with data access
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        // Create: owner and accountants only
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['userId', 'userEmail', 'action', 'module', 'description', 'createdAt'])
          && isValidString(request.resource.data.action)
          && isValidString(request.resource.data.module)
          && isValidString(request.resource.data.description)
          && request.resource.data.createdAt is timestamp;
        // Update/Delete: denied (immutable audit trail)
        allow update: if false;
        allow delete: if false;
      }

      // Journal Entries collection - قيود اليومية (double-entry bookkeeping)
      // CRITICAL: Server-side validation that debits = credits
      match /journal_entries/{entryId} {
        // Helper function to validate journal entry balance
        function isBalanced() {
          let data = request.resource.data;
          // totalDebits and totalCredits must be present and equal (within 0.01 tolerance for floating point)
          return data.totalDebits is number
            && data.totalCredits is number
            && data.totalDebits >= 0
            && data.totalCredits >= 0
            && math.abs(data.totalDebits - data.totalCredits) < 0.01;
        }

        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow create: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && hasRequiredFields(['entryNumber', 'date', 'description', 'lines', 'totalDebits', 'totalCredits', 'status', 'createdAt'])
          && isValidString(request.resource.data.entryNumber)
          && isValidString(request.resource.data.description)
          && request.resource.data.date is timestamp
          && request.resource.data.lines is list
          && request.resource.data.lines.size() > 0
          && request.resource.data.status in ['draft', 'posted', 'reversed']
          && request.resource.data.createdAt is timestamp
          && isBalanced();  // CRITICAL: Debits must equal Credits
        allow update: if canAccessOwnerData(userId) && canWrite(request.auth.uid)
          && isBalanced();  // CRITICAL: Debits must equal Credits on update too
        allow delete: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }

      // Catch-all for any other subcollections (incoming-cheques, outgoing-cheques, etc.)
      match /{collection}/{docId} {
        allow read: if canAccessOwnerData(userId) && canRead(request.auth.uid);
        allow write: if canAccessOwnerData(userId) && canWrite(request.auth.uid);
      }
    }

    // ============================================
    // ACCESS REQUESTS - For self-registration flow
    // ============================================

    match /access_requests/{requestId} {
      // Anyone authenticated can create an access request
      allow create: if isAuthenticated()
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.status == 'pending';

      // Read permissions:
      // 1. Target owner can read requests for their org
      // 2. Requester can read their own requests (to check pending status)
      allow read: if isAuthenticated() && (
        resource.data.targetOwnerId == request.auth.uid ||
        resource.data.uid == request.auth.uid
      );

      // Only the target org owner can approve/reject (update status)
      allow update: if isAuthenticated()
        && resource.data.targetOwnerId == request.auth.uid
        && request.resource.data.status in ['approved', 'rejected'];

      // No deletion - maintain audit trail
      allow delete: if false;
    }

    // ============================================
    // DENY ALL OTHER ACCESS
    // ============================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
